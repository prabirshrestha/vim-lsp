function! s:set_text(lines)
    % delete _
    put =a:lines
    execute 'normal ggdd'
endfunction

function! s:get_text()
    return lsp#utils#buffer#_get_lines(bufnr('$'))
endfunction

Describe lsp#utils#text_edit

    Before all
        let s:endofline_backup = &endofline
        set endofline
    End

    After all
        let &endofline = s:endofline_backup
    End

    Before each
        enew!
    End

    Describe lsp#utils#text_edit#apply_text_edits
        It insert newText
            call s:set_text(['foo', 'bar'])

            call lsp#utils#text_edit#apply_text_edits(
                    \ expand('%'),
                    \ [{
                    \   'range': {
                    \       'start': {
                    \           'line': 1,
                    \           'character': 1
                    \       },
                    \       'end': {
                    \           'line': 1,
                    \           'character': 1
                    \       }
                    \   },
                    \   'newText': 'baz'
                    \ }],
                    \ {'show_edits': 0})

            let l:buffer_text = s:get_text()
            Assert Equals(l:buffer_text, ['foo', 'bbazar', ''])
        End

        It insert empty newText
            call s:set_text(['foo', 'bar'])

            call lsp#utils#text_edit#apply_text_edits(
                    \ expand('%'),
                    \ [{
                    \   'range': {
                    \       'start': {
                    \           'line': 1,
                    \           'character': 1
                    \       },
                    \       'end': {
                    \           'line': 1,
                    \           'character': 1
                    \       }
                    \   },
                    \   'newText': ''
                    \ }],
                    \ {'show_edits': 0})

            let l:buffer_text = s:get_text()
            Assert Equals(l:buffer_text, ['foo', 'bar', ''])
        End

        It replace range string to newText
            call s:set_text(['foo', 'bar'])

            call lsp#utils#text_edit#apply_text_edits(
                    \ expand('%'),
                    \ [{
                    \   'range': {
                    \       'start': {
                    \           'line': 1,
                    \           'character': 0
                    \       },
                    \       'end': {
                    \           'line': 1,
                    \           'character': 1
                    \       }
                    \   },
                    \   'newText': 'replaced'
                    \ }],
                    \ {'show_edits': 0})

            let l:buffer_text = s:get_text()
            Assert Equals(l:buffer_text, ['foo', 'replacedar', ''])
        End

        It replace range string to empty newText
            call s:set_text(['foo', 'bar'])

            call lsp#utils#text_edit#apply_text_edits(
                    \ expand('%'),
                    \ [{
                    \   'range': {
                    \       'start': {
                    \           'line': 1,
                    \           'character': 0
                    \       },
                    \       'end': {
                    \           'line': 1,
                    \           'character': 1
                    \       }
                    \   },
                    \   'newText': ''
                    \ }],
                    \ {'show_edits': 0})

            let l:buffer_text = s:get_text()
            Assert Equals(l:buffer_text, ['foo', 'ar', ''])
        End

        It single line start character is -1
            call s:set_text(['foo', 'bar'])

            call lsp#utils#text_edit#apply_text_edits(
                    \ expand('%'),
                    \ [{
                    \   'range': {
                    \       'start': {
                    \           'line': 1,
                    \           'character': -1
                    \       },
                    \       'end': {
                    \           'line': 1,
                    \           'character': 3
                    \       }
                    \   },
                    \   'newText': ''
                    \ }],
                    \ {'show_edits': 0})

            let l:buffer_text = s:get_text()
            Assert Equals(l:buffer_text, ['foo', '', ''])
        End

        It single line start character is 0
            call s:set_text(['foo', 'bar'])

            call lsp#utils#text_edit#apply_text_edits(
                    \ expand('%'),
                    \ [{
                    \   'range': {
                    \       'start': {
                    \           'line': 1,
                    \           'character': 0
                    \       },
                    \       'end': {
                    \           'line': 1,
                    \           'character': 3
                    \       }
                    \   },
                    \   'newText': ''
                    \ }],
                    \ {'show_edits': 0})

            let l:buffer_text = s:get_text()
            Assert Equals(l:buffer_text, ['foo', '', ''])
        End

        It single line start character is 1
            call s:set_text(['foo', 'bar'])

            call lsp#utils#text_edit#apply_text_edits(
                    \ expand('%'),
                    \ [{
                    \   'range': {
                    \       'start': {
                    \           'line': 1,
                    \           'character': 1
                    \       },
                    \       'end': {
                    \           'line': 1,
                    \           'character': 3
                    \       }
                    \   },
                    \   'newText': ''
                    \ }],
                    \ {'show_edits': 0})

            let l:buffer_text = s:get_text()
            Assert Equals(l:buffer_text, ['foo', 'b', ''])
        End

        It single line end character is `len(getline('.')) - 1`
            call s:set_text(['foo', 'bar'])

            call lsp#utils#text_edit#apply_text_edits(
                    \ expand('%'),
                    \ [{
                    \   'range': {
                    \       'start': {
                    \           'line': 1,
                    \           'character': 0
                    \       },
                    \       'end': {
                    \           'line': 1,
                    \           'character': 2
                    \       }
                    \   },
                    \   'newText': ''
                    \ }],
                    \ {'show_edits': 0})

            let l:buffer_text = s:get_text()
            Assert Equals(l:buffer_text, ['foo', 'r', ''])
        End

        It single line end character is `len(getline('.'))`
            call s:set_text(['foo', 'bar'])

            call lsp#utils#text_edit#apply_text_edits(
                    \ expand('%'),
                    \ [{
                    \   'range': {
                    \       'start': {
                    \           'line': 1,
                    \           'character': 0
                    \       },
                    \       'end': {
                    \           'line': 1,
                    \           'character': 3
                    \       }
                    \   },
                    \   'newText': ''
                    \ }],
                    \ {'show_edits': 0})

            let l:buffer_text = s:get_text()
            Assert Equals(l:buffer_text, ['foo', '', ''])
        End

        It single line end character is `len(getline('.')) + 1`
            call s:set_text(['foo', 'bar'])

            call lsp#utils#text_edit#apply_text_edits(
                    \ expand('%'),
                    \ [{
                    \   'range': {
                    \       'start': {
                    \           'line': 1,
                    \           'character': 0
                    \       },
                    \       'end': {
                    \           'line': 1,
                    \           'character': 4
                    \       }
                    \   },
                    \   'newText': ''
                    \ }],
                    \ {'show_edits': 0})

            " if newline character deleting, need end position is next line zero character.
            let l:buffer_text = s:get_text()
            Assert Equals(l:buffer_text, ['foo', '', ''])
        End

        It replace range string to empty newText, multiline top to top
            call s:set_text(['foo', 'bar', 'baz'])

            call lsp#utils#text_edit#apply_text_edits(
                    \ expand('%'),
                    \ [{
                    \   'range': {
                    \       'start': {
                    \           'line': 0,
                    \           'character': 0
                    \       },
                    \       'end': {
                    \           'line': 1,
                    \           'character': 0
                    \       }
                    \   },
                    \   'newText': ''
                    \ }],
                    \ {'show_edits': 0})

            let l:buffer_text = s:get_text()
            Assert Equals(l:buffer_text, ['bar', 'baz', ''])
        End

        It replace range string to empty newText, multiline top to tail
            call s:set_text(['foo', 'bar', 'baz'])

            call lsp#utils#text_edit#apply_text_edits(
                    \ expand('%'),
                    \ [{
                    \   'range': {
                    \       'start': {
                    \           'line': 0,
                    \           'character': 0
                    \       },
                    \       'end': {
                    \           'line': 1,
                    \           'character': 2
                    \       }
                    \   },
                    \   'newText': ''
                    \ }],
                    \ {'show_edits': 0})

            let l:buffer_text = s:get_text()
            Assert Equals(l:buffer_text, ['r', 'baz', ''])

            call s:set_text(['foo', 'bar', 'baz'])

            call lsp#utils#text_edit#apply_text_edits(
                    \ expand('%'),
                    \ [{
                    \   'range': {
                    \       'start': {
                    \           'line': 0,
                    \           'character': 0
                    \       },
                    \       'end': {
                    \           'line': 1,
                    \           'character': 3
                    \       }
                    \   },
                    \   'newText': ''
                    \ }],
                    \ {'show_edits': 0})

            let l:buffer_text = s:get_text()
            Assert Equals(l:buffer_text, ['', 'baz', ''])

            call s:set_text(['foo', 'bar', 'baz'])

            call lsp#utils#text_edit#apply_text_edits(
                    \ expand('%'),
                    \ [{
                    \   'range': {
                    \       'start': {
                    \           'line': 0,
                    \           'character': 0
                    \       },
                    \       'end': {
                    \           'line': 1,
                    \           'character': 4
                    \       }
                    \   },
                    \   'newText': ''
                    \ }],
                    \ {'show_edits': 0})

            " if newline character deleting, need end position is next line zero character.
            let l:buffer_text = s:get_text()
            Assert Equals(l:buffer_text, ['', 'baz', ''])
        End

        It replace range string to empty newText, multiline middle to middle
            call s:set_text(['foo', 'bar', 'baz'])

            call lsp#utils#text_edit#apply_text_edits(
                    \ expand('%'),
                    \ [{
                    \   'range': {
                    \       'start': {
                    \           'line': 0,
                    \           'character': 1
                    \       },
                    \       'end': {
                    \           'line': 1,
                    \           'character': 2
                    \       }
                    \   },
                    \   'newText': ''
                    \ }],
                    \ {'show_edits': 0})

            let l:buffer_text = s:get_text()
            Assert Equals(l:buffer_text, ['fr', 'baz', ''])
        End

        It replaces entire buffer correctly
            call s:set_text(['foo', 'bar', 'baz'])

            call lsp#utils#text_edit#apply_text_edits(
                    \ expand('%'),
                    \ [{
                    \   'range': {
                    \       'start': {
                    \           'line': 0,
                    \           'character': 0
                    \       },
                    \       'end': {
                    \           'line': 3,
                    \           'character': 0
                    \       }
                    \   },
                    \   'newText': "x\ny\nz\n"
                    \ }],
                    \ {'show_edits': 0})

            let l:buffer_text = s:get_text()
            Assert Equals(l:buffer_text, ['x', 'y', 'z', ''])
        End

        It multiple textEdit with inserting \r.
            " Add some text to buffer
            call s:set_text(['class ABC {', '  private:', '  ', 'int a;};', ])

            " Format
            call lsp#utils#text_edit#apply_text_edits(
                    \ expand('%'),
                    \ [
                    \   {
                    \     "range": {
                    \       "end": {
                    \         "character": 2,
                    \         "line": 1
                    \       },
                    \       "start": {
                    \         "character": 11,
                    \         "line": 0
                    \       }
                    \     },
                    \     "newText": "\n"
                    \   },
                    \   {
                    \     "range": {
                    \       "end": {
                    \         "character": 0,
                    \         "line": 3
                    \       },
                    \       "start": {
                    \         "character": 10,
                    \         "line": 1
                    \       }
                    \     },
                    \     "newText": "\n  "
                    \   },
                    \   {
                    \     "range": {
                    \       "end": {
                    \         "character": 6,
                    \         "line": 3
                    \       },
                    \       "start": {
                    \         "character": 6,
                    \         "line": 3
                    \       }
                    \     },
                    \     "newText": "\n"
                    \   }
                    \ ],
                    \ {'show_edits': 0})

            let l:buffer_text = s:get_text()
            Assert Equals(l:buffer_text, ['class ABC {', 'private:', '  int a;', '};', ''])
        End

        It preserves v:completed_item
            " Add some text to buffer
            call s:set_text(['foo', 'bar'])

            " Go to end of file and invoke completion
            execute "normal Gof\<C-p>\<Esc>"

            " Make sure that v:completed_item is set
            Assert Equals(v:completed_item["word"], "foo")
            let l:old_completed_item = v:completed_item

            " Perform some text edits

            " Insert
            call lsp#utils#text_edit#apply_text_edits(
                    \ expand('%'),
                    \ [{
                    \   'range': {
                    \       'start': {
                    \           'line': 1,
                    \           'character': 1
                    \       },
                    \       'end': {
                    \           'line': 1,
                    \           'character': 1
                    \       }
                    \   },
                    \   'newText': 'baz'
                    \ }],
                    \ {'show_edits': 0})

            " Insert empty
            call lsp#utils#text_edit#apply_text_edits(
                    \ expand('%'),
                    \ [{
                    \   'range': {
                    \       'start': {
                    \           'line': 1,
                    \           'character': 1
                    \       },
                    \       'end': {
                    \           'line': 1,
                    \           'character': 1
                    \       }
                    \   },
                    \   'newText': ''
                    \ }],
                    \ {'show_edits': 0})

            " Replace
            call lsp#utils#text_edit#apply_text_edits(
                    \ expand('%'),
                    \ [{
                    \   'range': {
                    \       'start': {
                    \           'line': 1,
                    \           'character': 0
                    \       },
                    \       'end': {
                    \           'line': 1,
                    \           'character': 1
                    \       }
                    \   },
                    \   'newText': 'replaced'
                    \ }],
                    \ {'show_edits': 0})

            " Delete
            call lsp#utils#text_edit#apply_text_edits(
                    \ expand('%'),
                    \ [{
                    \   'range': {
                    \       'start': {
                    \           'line': 1,
                    \           'character': 0
                    \       },
                    \       'end': {
                    \           'line': 1,
                    \           'character': 1
                    \       }
                    \   },
                    \   'newText': ''
                    \ }],
                    \ {'show_edits': 0})

            " Make sure v:completed_item is not changed
            Assert Equals(v:completed_item, l:old_completed_item)
        End

        It replaces entire buffer correctly when end column is 1
            call s:set_text(['foo', 'b'])

            call lsp#utils#text_edit#apply_text_edits(
                    \ expand('%'),
                    \ [{
                    \   'range': {
                    \       'start': {
                    \           'line': 0,
                    \           'character': 0
                    \       },
                    \       'end': {
                    \           'line': 1,
                    \           'character': 1
                    \       }
                    \   },
                    \   'newText': "x\ny\nz\n"
                    \ }],
                    \ {'show_edits': 0})

            let l:buffer_text = s:get_text()
            Assert Equals(l:buffer_text, ['x', 'y', 'z', 'b', ''])
        End

        It adds imports correctly
            call s:set_text(['package main', '', 'import java.util.ArrayList;', '', 'public class Main {}'])

            call lsp#utils#text_edit#apply_text_edits(
                \ expand('%'),
                \ [{
                \     "range": {
                \       "start": {
                \         "character": 0,
                \         "line": 2
                \       },
                \       "end": {
                \         "character": 0,
                \         "line": 3
                \       }
                \     },
                \     "newText": ""
                \   },
                \   {
                \     "range": {
                \       "start": {
                \         "character": 0,
                \         "line": 2
                \       },
                \       "end": {
                \         "character": 0,
                \         "line": 2
                \       }
                \     },
                \     "newText": "import java.util.ArrayList;\n"
                \   }
                \ ],
                \ {'show_edits': 0})

            let l:buffer_text = s:get_text()
            Assert Equals(l:buffer_text, ['package main', '', 'import java.util.ArrayList;', '', 'public class Main {}', ''])
        End

        It populates location list with changes
            call lsp#utils#text_edit#apply_text_edits(
                \ expand('%'),
                \ [
                \ {
                \     "range": {
                \       "start": {
                \         "character": 0,
                \         "line": 3
                \       },
                \       "end": {
                \         "character": 0,
                \         "line": 3
                \       }
                \     },
                \     "newText": "import java.util.LinkedList;"
                \   },
                \   {
                \     "range": {
                \       "start": {
                \         "character": 0,
                \         "line": 2
                \       },
                \       "end": {
                \         "character": 0,
                \         "line": 2
                \       }
                \     },
                \     "newText": "import java.util.ArrayList;"
                \   }
                \ ],
                \ {'show_edits': 1})

            let l:loclist = getloclist(0)
            Assert Equals(len(l:loclist), 2)
            Assert Equals(map(l:loclist, {_, locitem -> locitem['text']}), ['import java.util.ArrayList;', 'import java.util.LinkedList;'])
        End
    End
End

